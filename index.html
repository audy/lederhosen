<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Lederhosen by audy</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Lederhosen</h1>
        <p>Turn 16S rRNA sequences into usable data</p>

        <p class="view"><a href="https://github.com/audy/lederhosen">View the Project on GitHub <small>audy/lederhosen</small></a></p>


        <ul>
          <li><a href="https://github.com/audy/lederhosen/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/audy/lederhosen/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/audy/lederhosen">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p><img src="https://raw.github.com/audy/lederhosen/master/logo.png" align="right"></p>

<h1>
<a name="lederhosen" class="anchor" href="#lederhosen"><span class="octicon octicon-link"></span></a>Lederhosen</h1>

<p>Lederhosen is a set of tools for OTU clustering rRNA amplicons using
Robert Edgar's USEARCH and is simple, robust, and fast.
Lederhosen was designed from the beginning to handle lots of data from
lots of samples, specifically from data generated by multiplexed
Illumina Hi/Mi-Seq sequencing.</p>

<p>No assumptions are made about the design of your experiment.
Therefore, there are no tools for read pre-processing and data analysis
or statistics. Insert reads, receive data.</p>

<h3>
<a name="about" class="anchor" href="#about"><span class="octicon octicon-link"></span></a>About</h3>

<ul>
<li>Lederhosen is designed to be a fast and <strong>simple</strong> (~700 SLOC) tool to aid in clustering 16S rRNA amplicons sequenced
using paired and non-paired end short reads such as those produced by Illumina (GAIIx, HiSeq and MiSeq), Ion Torrent, or Roche-454.</li>
<li>Lederhosen uses <a href="http://semver.org/">Semantic Versioning</a>, is free and open source under the
<a href="http://opensource.org/licenses/mit-license.php/">MIT open source license</a>.</li>
<li>Except for USEARCH which requires a license, Lederhosen is available for commercial use.</li>
</ul><h3>
<a name="features" class="anchor" href="#features"><span class="octicon octicon-link"></span></a>Features</h3>

<ul>
<li>Referenced-based OTU clustering to via USEARCH.</li>
<li>Multiple Database Support (RDP, GreenGenes, TaxCollector, Silva).</li>
<li>Parallel support (USEARCH, MapReduce or Compute Cluster).</li>
<li>Generation and filtering of OTU abundancy matrices.</li>
</ul><h3>
<a name="installation" class="anchor" href="#installation"><span class="octicon octicon-link"></span></a>Installation</h3>

<ol>
<li>Obtain &amp; Install <a href="http://www.drive5.com/">USEARCH</a>.</li>
<li>Get a database:

<ul>
<li><a href="http://github.com/audy/taxcollector">TaxCollector</a></li>
<li>
<a href="http://greengenes.lbl.gov">GreenGenes</a> 16S database</li>
<li>File an <a href="https://github.com/audy/lederhosen/issues">issue report</a> or pull request ;) to request support for a different database.</li>
</ul>
</li>
<li>
<p>Install Lederhosen by typing:</p>

<p><code>sudo gem install lederhosen</code></p>
</li>
<li><p>Check installation by typing <code>lederhosen</code>. You should see some help text.</p></li>
</ol><h3>
<a name="need-help" class="anchor" href="#need-help"><span class="octicon octicon-link"></span></a>Need Help?</h3>

<p>Bug me: <a href="http://twitter.com/heyaudy">@heyaudy</a> (twitter)</p>

<h2>
<a name="tasks" class="anchor" href="#tasks"><span class="octicon octicon-link"></span></a>Tasks</h2>

<p>Lederhosen is invoked by typing <code>lederhosen [TASK]</code></p>

<h3>
<a name="trim-reads" class="anchor" href="#trim-reads"><span class="octicon octicon-link"></span></a>Trim Reads</h3>

<p>Trimming removed. I think you should use
<a href="https://github.com/najoshi/sickle">Sickle</a>, or
<a href="http://www.usadellab.org/cms/index.php?page=trimmomatic">Trimmomatic</a>.
You can use
<a href="http://www.bioinformatics.babraham.ac.uk/projects/fastqc/">FastQC</a> to inspect read quality.</p>

<h3>
<a name="create-database" class="anchor" href="#create-database"><span class="octicon octicon-link"></span></a>Create Database</h3>

<p>Create UDB database required by usearch from TaxCollector</p>

<div class="highlight"><pre>lederhosen make_udb <span class="se">\</span>
  --input<span class="o">=</span>taxcollector.fa <span class="se">\</span>
  --output<span class="o">=</span>taxcollector.udb
</pre></div>

<p>(not actually required but will make batch searching a lot faster)</p>

<h3>
<a name="cluster-reads-using-usearch" class="anchor" href="#cluster-reads-using-usearch"><span class="octicon octicon-link"></span></a>Cluster Reads using USEARCH</h3>

<p>Cluster reads using USEARCH. Output is a uc file.</p>

<div class="highlight"><pre>lederhosen cluster <span class="se">\</span>
  --input<span class="o">=</span>trimmed/sequences.fasta <span class="se">\</span>
  --identity<span class="o">=</span>0.95 <span class="se">\</span>
  --output<span class="o">=</span>clusters_95.uc <span class="se">\</span>
  --database<span class="o">=</span>taxcollector.udb
</pre></div>

<p>The optional <code>--dry-run</code> parameter outputs the usearch command to standard out.
This is useful if you want to run usearch on a cluster.</p>

<div class="highlight"><pre><span class="k">for </span>reads_file in reads/*.fasta;
<span class="k">do</span>
<span class="k">    </span><span class="nb">echo </span>lederhosen cluster <span class="se">\</span>
                    --input<span class="o">=</span><span class="nv">$reads_file</span> <span class="se">\</span>
                    --identity<span class="o">=</span>0.95 <span class="se">\</span>
                    --output<span class="o">=</span><span class="k">$(</span>basename <span class="nv">$reads_file_</span> .fasta<span class="k">)</span>.95.uc <span class="se">\</span>
                    --database<span class="o">=</span>taxcollector.udb <span class="se">\</span>
                    --threads 1 <span class="se">\</span>
                    --dry-run
end &gt; jobs.sh

<span class="c"># send jobs to queue system</span>
cat jobs.sh | parallel -j 24 <span class="c"># run 24 parallel jobs</span>
</pre></div>

<h3>
<a name="generate-taxonomy-counts-tables" class="anchor" href="#generate-taxonomy-counts-tables"><span class="octicon octicon-link"></span></a>Generate taxonomy counts tables</h3>

<p>Before generating OTU tables, you must generate taxonomy counts tables.</p>

<p>A taxonomy count table looks something like this</p>

<pre><code># taxonomy, number_of_reads
[0]Bacteria[1];...;[8]Akkermansia_municipalia, 28
...
</code></pre>

<p>From there, you can generate OTU abundance matrices at the different levels of classification (domain, phylum, ..., genus, species).</p>

<div class="highlight"><pre>
lederhosen count_taxonomies <span class="se">\</span>
  --input<span class="o">=</span>clusters.uc <span class="se">\</span>
  --output<span class="o">=</span>clusters_taxonomies.txt
</pre></div>

<p>If you did paired-end sequencing, you can generate strict taxonomy tables that only count reads when <em>both pairs</em> have the <em>same</em>
taxonomic description at a certain taxonomic level. This is useful for leveraging the increased length of having pairs and also
acts as a sort of chimera filter. You will, however, end up using less of your reads as the level goes from domain to species.</p>

<div class="highlight"><pre>lederhosen count_taxonomies <span class="se">\</span>
  --input<span class="o">=</span>clusters.uc <span class="se">\</span>
  --strict<span class="o">=</span>genus <span class="se">\</span>
  --output<span class="o">=</span>clusters_taxonomies.strict.genus.txt
</pre></div>

<p>Reads that do not have the same phylogeny at <code>level</code> will become <code>unclassified_reads</code></p>

<h3>
<a name="generate-otu-tables" class="anchor" href="#generate-otu-tables"><span class="octicon octicon-link"></span></a>Generate OTU tables</h3>

<p>Create an OTU abundance table where rows are samples and columns are clusters. The entries are the number of reads for that cluster in a sample.</p>

<div class="highlight"><pre>lederhosen otu_table <span class="se">\</span>
  --files<span class="o">=</span>clusters_taxonomies.strict.genus.*.txt <span class="se">\</span>
  --output<span class="o">=</span>my_poop_samples_genus_strict.95.txt <span class="se">\</span>
  --level<span class="o">=</span>genus
</pre></div>

<p>This will create the file <code>my_poop_samples_genus_strict.95.txt</code> containing the clusters
as columns and the samples as rows.</p>

<p>You now will apply advanced data mining and statistical techniques to this table to make
interesting biological inferences and cure diseases.</p>

<h3>
<a name="filter-otu-tables" class="anchor" href="#filter-otu-tables"><span class="octicon octicon-link"></span></a>Filter OTU tables</h3>

<p>Sometimes, clustering high-throughput reads at stringent identities can create many, small clusters.
In fact, these clusters represent the vast majority (&gt;99%) of the created clusters but the minority ()
of the reads. In other words, 1% of the reads have 99% of the clusters.</p>

<p>If you want to filter out these small clusters which are composed of inseparable sequencing error or
actual biodiversity, you can do so with the <code>otu_filter</code> task.</p>

<div class="highlight"><pre>lederhosen otu_filter <span class="se">\</span>
  --input<span class="o">=</span>table.csv <span class="se">\</span>
  --output<span class="o">=</span>filtere.csv <span class="se">\</span>
  --reads<span class="o">=</span>50 <span class="se">\</span>
  --samples<span class="o">=</span>50
</pre></div>

<p>This will remove any clusters that do not appear in at least 10 samples with at least 50 reads. The read counts
for filtered clusters will be moved to the <code>noise</code> psuedocluster.</p>

<h3>
<a name="get-representative-sequences" class="anchor" href="#get-representative-sequences"><span class="octicon octicon-link"></span></a>Get representative sequences</h3>

<p>You can get the representative sequences for each cluster using the <code>get_reps</code> tasks.
This will extract the representative sequence from the <strong>database</strong> you ran usearch with.
Make sure you use the same database that you used when running usearch.</p>

<div class="highlight"><pre>lederhosen get_reps <span class="se">\</span>
  --input<span class="o">=</span>clusters.uc <span class="se">\</span>
  --database<span class="o">=</span>taxcollector.fa <span class="se">\</span>
  --output<span class="o">=</span>representatives.fasta
</pre></div>

<p>You can get the representatives from more than one cluster file using a glob:</p>

<div class="highlight"><pre>lederhosen get_reps <span class="se">\</span>
  --input<span class="o">=</span>*.uc <span class="se">\</span>
  --database<span class="o">=</span>taxcollector.fa <span class="se">\</span>
  --output<span class="o">=</span>representatives.fasta
</pre></div>

<h3>
<a name="get-unclassified-sequences" class="anchor" href="#get-unclassified-sequences"><span class="octicon octicon-link"></span></a>Get unclassified sequences</h3>

<div class="highlight"><pre>lederhosen separate_unclassified <span class="se">\</span>
  --uc-file<span class="o">=</span>my_results.uc <span class="se">\</span>
  --reads<span class="o">=</span>reads_that_were_used_to_generate_results.fasta
  --output<span class="o">=</span>unclassified_reads.fasta
</pre></div>

<p><code>separate_unclassified</code> has support for strict pairing</p>

<pre><code>lederhosen separate_unclassified \
  --uc-file=my_results.uc \
  --reads=reads_that_were_used_to_generate_results.fasta
  --strict=phylum
  --output=unclassified_reads.fasta
</code></pre>

<h2>
<a name="acknowledgements" class="anchor" href="#acknowledgements"><span class="octicon octicon-link"></span></a>Acknowledgements</h2>

<ul>
<li>Lexi, Vinnie and Kevin for beta-testing and putting up with bugs</li>
<li>The QIIME project for inspiration</li>
<li>Sinbad Richardson for the Lederhosen Guy artwork</li>
</ul><h2>
<a name="please-cite" class="anchor" href="#please-cite"><span class="octicon octicon-link"></span></a>Please Cite</h2>

<p>Please cite this GitHub repo (<a href="https://github.com/audy/lederhosen">https://github.com/audy/lederhosen</a>) with the version you used (type <code>lederhosen version</code>) unless I publish a paper. Then cite that.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/audy">audy</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>